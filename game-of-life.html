<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="description" content="Game of life- Conway" />
		<title>Game of life</title>
		<style>
			body {
				font-family: Verdana, Geneva, Tahoma, sans-serif, sans-serif;
				background-color: #f0f0f0;
			}

			h1 {
				text-align: center;
				margin-top: 20px;
			}

			canvas {
				border: 5px solid blueviolet;
				display: block;
				margin: 0 auto;
			}
			span,
            b,
			li {
				font-style: italic;
				font-size: small;
			}
		</style>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
	</head>

	<body>
		<h1>Game of life - Conway's</h1>
		<canvas id="canvas" width="1200" height="700">
			Your browser does not support the HTML5 canvas tag.
		</canvas>
        <b>Generations</b> :: <span id="sEnd"></span>
		<p>
			<b>Rules</b>
		</p>
		<ol>
			<li>
				Each cell interacts with its eight neighbors, those
				horizontally, vertically, or diagonally adjacent.
			</li>
			<li>
				Any live cell with fewer than two live neighbours dies, as if by
				underpopulation.
			</li>
			<li>
				Any live cell with two or three live neighbours lives on to the
				next generation.
			</li>
			<li>
				Any live cell with more than three live neighbours dies, as if
				by overpopulation.
			</li>
			<li>
				Any dead cell with exactly three live neighbours becomes a live
				cell, as if by reproduction.
			</li>
		</ol>
        <b>Start</b>
		<canvas id="canvasStart" width="1200" height="700">
			Your browser does not support the HTML5 canvas tag.
		</canvas>

        <script>
            function MD5(message) { 
                return CryptoJS.MD5(message).toString(); 
            }

			class Cell {
				static width = 10;
				static height = 10;

				constructor(context, gridX, gridY) {
					this.context = context;

					this.gridX = gridX;
					this.gridY = gridY;

					this.alive = Math.random() > 0.5;
				}

				draw() {
					this.context.fillStyle = this.alive ? "#ffa500" : "#333333";
					this.context.fillRect(
						this.gridX * Cell.width,
						this.gridY * Cell.height,
						Cell.width,
						Cell.height
					);
				}
			}

			class GameWorld {
				static numColumns = 120;
				static numRows = 70;

                lastStates = [];
                cycleCheck = [];
                iteration = 0;
                state = "";
                stable = false;

				constructor(canvasId, animate) {
					this.canvas = document.getElementById(canvasId);
					this.context = this.canvas.getContext("2d");
					this.gameObjects = [];

					this.createGrid();

                    if (animate){
                        let gameWorldStart = new GameWorld("canvasStart", false);
                        for (let i = 0; i < this.gameObjects.length; i++) {
                            gameWorldStart.gameObjects.push(new Cell(gameWorldStart.context, this.gameObjects[i].gridX, this.gameObjects[i].gridY));
                            gameWorldStart.gameObjects[i].draw();
                        }
                        window.requestAnimationFrame(() => this.gameLoop());
                    }    

				}

				createGrid() {
					for (let y = 0; y < GameWorld.numRows; y++) {
						for (let x = 0; x < GameWorld.numColumns; x++) {
							this.gameObjects.push(new Cell(this.context, x, y));
						}
					}
				}

				isAlive(x, y) {
					if (
						x < 0 ||
						x >= GameWorld.numColumns ||
						y < 0 ||
						y >= GameWorld.numRows
					) {
						return false;
					}

					return this.gameObjects[this.gridToIndex(x, y)].alive
						? 1
						: 0;
				}

				gridToIndex(x, y) {
					return x + y * GameWorld.numColumns;
				}

				checkNeighbours() {
					for (let x = 0; x < GameWorld.numColumns; x++) {
						for (let y = 0; y < GameWorld.numRows; y++) {
							// Count the nearby population
							let numAlive =
								this.isAlive(x - 1, y - 1) +
								this.isAlive(x, y - 1) +
								this.isAlive(x + 1, y - 1) +
								this.isAlive(x - 1, y) +
								this.isAlive(x + 1, y) +
								this.isAlive(x - 1, y + 1) +
								this.isAlive(x, y + 1) +
								this.isAlive(x + 1, y + 1);
							let centerIndex = this.gridToIndex(x, y);

							if (numAlive == 2) {
								// Do nothing
								this.gameObjects[centerIndex].nextAlive =
									this.gameObjects[centerIndex].alive;
							} else if (numAlive == 3) {
								// Make alive
								this.gameObjects[centerIndex].nextAlive = true;
							} else {
								// Make dead
								this.gameObjects[centerIndex].nextAlive = false;
							}
						}
					}

					for (let i = 0; i < this.gameObjects.length; i++) {
						this.gameObjects[i].alive =
							this.gameObjects[i].nextAlive;
					}
				}

				gameLoop() {
					this.checkNeighbours();

					this.context.clearRect(
						0,
						0,
						this.canvas.width,
						this.canvas.height
					);

                    this.state = "";
					for (let i = 0; i < this.gameObjects.length; i++) {
						this.gameObjects[i].draw();
                        this.state += this.gameObjects[i].alive?"1":"0";
					}
                    this.state = MD5(this.state);

                    if (this.checkEnd()) {
                        this.stable = true;
                        const message = `Lived for ${this.iteration} generations, stable now. Do you want to reset?`; 
                        if (confirm(message)) { 
                            gameWorld = new GameWorld("canvas", true);
                        }
                    }
                    else{
                        this.iteration += 1;
                    }

					if (!this.stable)
                        setTimeout(() => {
                            window.requestAnimationFrame(() => this.gameLoop());
                        }, 100);
				}

                checkEnd() {
                    this.lastStates.push(this.state);
                    const isSame = this.lastStates.length > 2 && this.lastStates.every(curr => curr === this.lastStates[0]);

                    this.cycleCheck.push(this.state);
                    if (this.cycleCheck.length > 4){
                        this.cycleCheck.shift();
                    } 
                    const isCycling = (this.cycleCheck.length == 4) && (this.cycleCheck[0] === this.cycleCheck[2]) && (this.cycleCheck[1] === this.cycleCheck[3]);

                    document.getElementById("sEnd").innerText = this.iteration;

                    return isSame || isCycling;
                }
			}

			window.onload = () => {
				let gameWorld = new GameWorld("canvas", true);
			};
		</script>
	</body>
</html>
